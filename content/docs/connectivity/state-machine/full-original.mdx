---
title: State Machine
description: The Persistent Connectivity State Machine - A unified system for WiFi and BLE recovery
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Mermaid } from '@/components/mermaid'
import { Accordion, Accordions } from 'fumadocs-ui/components/accordion'

<Callout title="Core Principle">
  "The device is always reachable." Either via internet (ONLINE) or BLE (RECOVERING). Never truly lost. This isn't onboarding AND recovery - it's ONE system that handles both.
</Callout>

## The State Machine

The Persistent Connectivity System is built on a simple 3-state machine:

<Mermaid chart={`
stateDiagram-v2
    [*] --> RECOVERING: First boot
    RECOVERING --> CONNECTING: User provisions WiFi<br/>OR cached network found
    CONNECTING --> ONLINE: WiFi success +<br/>Internet verified
    ONLINE --> RECOVERING: WiFi lost OR<br/>Verification fails
    CONNECTING --> RECOVERING: Connection fails<br/>OR timeout
    RECOVERING --> RECOVERING: Self-healing retries<br/>(background)

    note right of ONLINE
        ‚úÖ WiFi connected
        ‚úÖ Internet verified
        üî¥ BLE radio OFF
    end note

    note right of RECOVERING
        ‚ùå WiFi lost/failed
        üü¢ BLE radio ON
        üì± QR code visible
        üîÑ Self-healing active
    end note

    note right of CONNECTING
        ‚è≥ Attempting WiFi
        üü¢ BLE still ON
        üìä Monitoring signal
        ‚è±Ô∏è Exponential backoff
    end note
`} />

---

## State Definitions

### ONLINE State

**Meaning:** Device is fully operational with internet access.

**Behaviors:**
- WiFi connected AND internet verification passed (HTTP GET to health endpoint)
- BLE radio is OFF (hidden mode - saves power)
- Device working normally, app shows green status
- Background monitoring continues (watching for failures)

**Exit Conditions:**
- WiFi signal drops ‚Üí RECOVERING
- Connectivity verification fails (no internet) ‚Üí RECOVERING
- WiFi auth fails (password changed) ‚Üí RECOVERING
- Any connectivity failure ‚Üí RECOVERING

---

### RECOVERING State

**Meaning:** Device lost internet. Self-healing and user recovery both active.

**Behaviors:**
- **BLE radio ON** - Pairing mode active, broadcasting device name
- **Display shows:** "No Internet - Scan QR to reconnect"
- **Self-healing running** - Background retries of cached networks
- **User can intervene** - Scan QR ‚Üí BLE connection ‚Üí WiFi provisioning

**This is identical to onboarding!** The recovery flow reuses the onboarding BLE + WiFi provisioning system.

**Self-Healing Process (Background):**
1. Scan for all cached networks
2. Try networks in smart order (recency + signal strength)
3. Exponential backoff to prevent battery drain
4. If found and connected ‚Üí silently transition to CONNECTING
5. If all fail ‚Üí stay in RECOVERING, wait for user

**User Recovery Process:**
1. User scans QR code ‚Üí App opens
2. App searches for BLE device
3. User enters device password (security gate)
4. App shows WiFi networks
5. User selects network ‚Üí App sends credentials via BLE
6. Transition to CONNECTING

**Exit Conditions:**
- Self-healing finds cached network ‚Üí CONNECTING
- User provisions new WiFi ‚Üí CONNECTING
- Never exits until WiFi is attempted

---

### CONNECTING State

**Meaning:** Device is attempting WiFi connection (user-initiated or cached network).

**Behaviors:**
- **WiFi connection in progress** - Device trying to join network
- **BLE still ON** - Safety net remains active during attempt
- **Exponential backoff** - Prevents hammering the network
- **Signal strength monitoring** - RSSI-based retry strategy
- **Timeout detection** - Gives up after reasonable time

**Smart Retry Strategy:**
- Strong signal (-50 to -70 dBm): Gentle backoff (1s, 2s, 4s, 8s...)
- Weak signal (-70 to -80 dBm): Aggressive backoff (4s, 8s, 16s, 32s...)
- Very weak (< -80 dBm): Give up after N retries ‚Üí RECOVERING

**Exit Conditions:**
- WiFi connects AND verification passes ‚Üí ONLINE (BLE turns OFF)
- Connection fails OR timeout ‚Üí RECOVERING
- Wrong password ‚Üí RECOVERING
- No internet after connection ‚Üí RECOVERING

---

## The Four Subsystems

The state machine is implemented by four integrated subsystems:

### 1. State Machine (The Core)

**Purpose:** Track device connectivity state and orchestrate transitions.

**Implementation:** The BLE Monitor from onboarding flow IS this state machine.
- Green status = ONLINE
- Amber status = RECOVERING or CONNECTING
- Red status = BLE lost (fatal - restart onboarding)

**State Persistence:**
- Device always knows current state
- App can query state via BLE (if connected) or heartbeat (if online)
- State survives app crashes (device is source of truth)

---

### 2. Self-Healing (Background Process)

**Purpose:** Silent auto-recovery without user intervention.

**Runs in:** RECOVERING state (background, parallel to user recovery option).

**Smart Retry Ordering:**
```
Priority Tiers:
1. Tier 1: Networks connected in last 7 days (ordered by recency)
2. Tier 2: Networks connected in last 30 days
3. Tier 3: Networks connected ever (deprioritized)

Within each tier: Sort by signal strength (stronger first)
```

**Behaviors:**
- Scans for all cached networks continuously
- Tries networks with exponential backoff (prevents battery drain)
- Monitors RSSI (signal strength) to adjust retry intensity
- Runs for 15-30 minutes before giving up
- **If succeeds:** Silent transition to ONLINE (user sees nothing!)
- **If fails:** Device stays in RECOVERING, BLE visible for user

**Network Caching Intelligence:**
- Cache by BSSID + SSID (not just SSID name)
- Prevents connecting to wrong "HomeNetwork" at different location
- Credentials age over time (> 90 days = deprioritized)
- Successful connection updates recency timestamp

---

### 3. Recovery Flow (User Intervention)

**Purpose:** User-driven recovery when self-healing fails or user wants to change networks.

**Critical Realization:** This IS the onboarding flow! Recovery reuses the exact same BLE + WiFi provisioning system.

**Flow Steps:**
1. **QR Code Display** - Device shows QR + "No Internet"
2. **BLE Pairing** - User scans ‚Üí App discovers device ‚Üí BLE connection
3. **Authentication** - App requests device password (security gate)
4. **WiFi Selection** - App shows available networks
5. **Credential Provisioning** - User selects network ‚Üí App sends via BLE
6. **Connection Attempt** - Device transitions to CONNECTING

**Prerequisites-Based Resumption (Stateless):**
- If app crashes mid-recovery, on relaunch:
  - Check: Is BLE connected?
  - If NO: Start from QR scan
  - If YES: Check auth status
    - If authenticated: Jump to WiFi selection
    - If not: Jump to password entry
- Device doesn't track "recovery sessions" - only current state matters
- BLE connection itself is the source of truth

**BLE Never Hides (Until Internet):**
- BLE pairing mode stays ON indefinitely (no 60s timeout)
- Only turns OFF when WiFi reconnects AND verification passes
- BLE is the safety net - never remove it until device is truly online

---

### 4. Intelligence Layer (Cross-Cutting)

**Purpose:** Smart decision-making that improves all subsystems.

**Connectivity Verification:**
```
After WiFi Connection:
1. Make HTTP GET request to known endpoint (e.g., api.pamir.cloud/health)
2. Expect: 200 OK = internet available
3. Timeout/error = no internet

If No Internet:
- Don't transition to ONLINE
- Stay in CONNECTING ‚Üí Fall back to RECOVERING
- Show specific error: "WiFi Connected, No Internet"
```

**BSSID + SSID Tracking:**
- Cache networks by unique BSSID (AP MAC address) + SSID pair
- Prevents confusion between networks with same name
- Example: "HomeNetwork" at home vs office are different BSSIDs
- Device won't accidentally connect to wrong one

**Signal Strength Monitoring (RSSI):**
- Strong: -50 to -70 dBm (retry normally)
- Weak: -70 to -80 dBm (backoff more aggressively)
- Very Weak: < -80 dBm (give up, enter RECOVERING)
- Prevents "flapping" (rapid connect/disconnect cycles)

**Credential Aging:**
- Networks last connected > 90 days are deprioritized
- Prevents hammering dead networks
- User can still manually select old network via recovery flow

---

## Connection to Onboarding

**The Critical Insight:** Onboarding flow already implements this state machine!

### Onboarding is RECOVERING State

**Chunk 1 (App Discovery):**
- Device displays QR code ‚Üê RECOVERING state display
- User scans ‚Üí App opens ‚Üê Recovery initiation

**Chunk 2 (BLE Setup):**
- BLE pairing mode ‚Üê RECOVERING state behavior
- Security authentication ‚Üê Recovery security gate
- BLE Monitor spawned ‚Üê State machine implementation

**Chunk 3 (WiFi Provisioning):**
- WiFi network list ‚Üê Recovery WiFi selection
- Credential transmission ‚Üê Recovery provisioning
- Connection attempt ‚Üê Transition to CONNECTING
- Success ‚Üí ONLINE (BLE turns off)

### After Onboarding

**Normal Operation:**
- Device enters ONLINE state (BLE off, WiFi working)
- BLE Monitor (state machine) keeps watching
- If WiFi breaks ‚Üí device re-enters RECOVERING state
- **Recovery uses the exact same BLE + WiFi provisioning flow!**

**We didn't design onboarding AND recovery separately. We designed ONE SYSTEM that handles both.**

---

## How It Solves Real-World Scenarios

The state machine naturally handles connectivity problems without special-case code. Here are common scenarios:

<Accordions>

<Accordion title="WiFi Password Changed">

**Scenario:** User changes router password. Device is still connected but suddenly gets kicked off.

**What Happens:**
```
Initial State: ONLINE
‚Üì
Router rejects device (auth failure)
‚Üì
Device detects: WiFi connection lost
‚Üì
Transition: ONLINE ‚Üí RECOVERING
‚Üì
Self-healing: Tries cached credentials (fails - wrong password)
‚Üì
Display shows: "No Internet - Scan QR"
BLE turns ON
‚Üì
User scans QR ‚Üí BLE connects ‚Üí Enters device password
‚Üì
App shows WiFi networks ‚Üí User selects network ‚Üí Enters NEW password
‚Üì
Transition: RECOVERING ‚Üí CONNECTING
‚Üì
WiFi succeeds + verification passes
‚Üì
Transition: CONNECTING ‚Üí ONLINE (BLE turns off)
```

**Result:** Device recovers. New password cached for future.

</Accordion>

<Accordion title="Device Moves Between Locations (Home ‚Üí Office)">

**Scenario:** User unplugs device at home, carries it to office.

**What Happens:**
```
Initial State: ONLINE (connected to HomeNetwork)
‚Üì
User unplugs device, carries to office
‚Üì
Device detects: WiFi signal lost
‚Üì
Transition: ONLINE ‚Üí RECOVERING
‚Üì
Self-healing: Scans for cached networks
‚Üì
Finds: OfficeNetwork (cached from previous visit)
‚Üì
Silently tries: OfficeNetwork with cached credentials
‚Üì
Transition: RECOVERING ‚Üí CONNECTING
‚Üì
WiFi succeeds + verification passes
‚Üì
Transition: CONNECTING ‚Üí ONLINE
```

**Result:** User sees NOTHING (silent recovery!). Device just works at new location.

</Accordion>

<Accordion title="WiFi Connected but No Internet">

**Scenario:** Router is up, WiFi connects, but ISP is down. Or captive portal requires login.

**What Happens:**
```
Initial State: RECOVERING
‚Üì
User provisions WiFi via BLE
‚Üì
Transition: RECOVERING ‚Üí CONNECTING
‚Üì
WiFi connection succeeds
‚Üì
Connectivity verification: HTTP GET to health endpoint
‚Üì
Result: Timeout (no internet detected)
‚Üì
Intelligence Layer catches: Connected but no internet
‚Üì
Transition: CONNECTING ‚Üí RECOVERING (don't go to ONLINE!)
‚Üì
Display shows: "WiFi Connected, No Internet"
‚Üì
App shows: "Try a different network or check your router"
‚Üì
User provisions different network OR waits for ISP
‚Üì
Repeat until verification passes ‚Üí ONLINE
```

**Result:** Device never falsely reports "online" when internet is broken.

</Accordion>

<Accordion title="Weak Signal / WiFi Flapping">

**Scenario:** Device is at edge of WiFi range. Signal keeps dropping and reconnecting.

**What Happens:**
```
Device monitors RSSI (signal strength)
‚Üì
Detects: Signal is very weak (< -80 dBm)
‚Üì
Connection drops
‚Üì
Transition: ONLINE ‚Üí RECOVERING ‚Üí CONNECTING
‚Üì
CONNECTING state applies: Exponential backoff based on signal strength
‚Üì
Weak signal detected ‚Üí Aggressive backoff (4s, 8s, 16s, 32s...)
‚Üì
Prevents: Rapid reconnect attempts (battery drain, network spam)
‚Üì
After N failed attempts with weak signal:
‚Üì
Give up ‚Üí Transition: CONNECTING ‚Üí RECOVERING
‚Üì
Display shows: "No Internet - Scan QR"
‚Üì
User moves device closer OR connects via BLE to provision stronger network
```

**Result:** Device doesn't hammer the network. Saves battery. Clear user path.

</Accordion>

<Accordion title="App Crashes Mid-Recovery">

**Scenario:** User is recovering device via BLE. App crashes (force quit, iOS killed it).

**What Happens:**
```
Initial State: RECOVERING
‚Üì
User scans QR ‚Üí BLE connects ‚Üí Enters device password
‚Üì
App showing WiFi list
‚Üì
App crashes (user force-quits)
‚Üì
Device stays in: RECOVERING (BLE still on, state persisted)
‚Üì
User relaunches app
‚Üì
App checks: Is BLE connected? YES
App checks: Is device authenticated? YES
‚Üì
App auto-advances to: WiFi selection screen
‚Üì
User continues from where they left off
‚Üì
No restart needed! (stateless resumption based on prerequisites)
```

**Result:** Recovery survives app crashes. User never has to start over.

</Accordion>

<Accordion title="Multiple Devices Nearby (Discovery Confusion)">

**Scenario:** User has 3 Distillers (home, office, friend's house). All are in pairing mode. App finds all 3.

**What Happens:**
```
All devices in RECOVERING state
‚Üì
All broadcasting BLE: "Distiller-A4F2", "Distiller-B8C9", "Distiller-D2E5"
‚Üì
User scans QR code on their device (e.g., Distiller-A4F2)
‚Üì
QR encodes: device ID + MAC address + device name
‚Üì
App knows: "I'm looking for Distiller-A4F2"
‚Üì
App scans BLE, finds multiple devices
‚Üì
App shows list with:
- Device names (from BLE advertisement)
- Signal strength (RSSI - strongest = closest)
‚Üì
App auto-selects: Distiller-A4F2 (from QR code)
‚Üì
User confirms: "Yes, that's my device" (optional visual confirmation)
‚Üì
BLE connects to correct device
‚Üì
Recovery proceeds normally
```

**Result:** User never connects to wrong device. QR code + RSSI + visual confirmation = 3 layers of safety.

</Accordion>

<Accordion title="Wrong Device Password During Recovery">

**Scenario:** User connects via BLE but enters wrong device password.

**What Happens:**
```
User scans QR ‚Üí BLE connects
‚Üì
App requests: Device password
‚Üì
User enters: Wrong password
‚Üì
Device validates: WRONG
‚Üì
Device sends: "Invalid Password" (explicit error)
‚Üì
BLE connection stays OPEN (does NOT disconnect)
‚Üì
App shows: "Incorrect device password. Try again."
‚Üì
User can immediately re-enter password (no rescan needed)
‚Üì
User retries (up to 5 attempts before disconnect for DoS protection)
‚Üì
Correct password ‚Üí Recovery proceeds
```

**Result:** User doesn't have to restart entire flow on typo. Respects user recovery attempts.

</Accordion>

<Accordion title="Similar Network Names (HomeNetwork at Home vs Office)">

**Scenario:** Home has "HomeNetwork" (router 1). Office has "HomeNetwork" (router 2). Device shouldn't confuse them.

**What Happens:**
```
During onboarding at home:
‚Üì
User selects "HomeNetwork"
‚Üì
Device caches: SSID="HomeNetwork" + BSSID="AA:BB:CC:DD:EE:FF"
‚Üì
Later, at office:
‚Üì
User provisions "HomeNetwork" (different router)
‚Üì
Device caches: SSID="HomeNetwork" + BSSID="11:22:33:44:55:66"
‚Üì
Device now knows: TWO distinct networks with same name
‚Üì
When device scans for cached networks:
‚Üì
Matches on BSSID first (most specific)
‚Üì
At home: Connects to BSSID AA:BB:CC (home router)
At office: Connects to BSSID 11:22:33 (office router)
‚Üì
Never accidentally connects to wrong network
```

**Result:** BSSID tracking prevents network confusion. Each router is unique.

</Accordion>

<Accordion title="All Cached Networks Are Stale/Gone">

**Scenario:** Device has 5 cached networks. WiFi infrastructure changed - all 5 are gone or have new passwords.

**What Happens:**
```
Device in RECOVERING state
‚Üì
Self-healing: Tries cached networks in order (10s timeout per network)
‚Üì
Network 1: Not found (timeout)
Network 2: Wrong password (auth failure)
Network 3: Not found (timeout)
Network 4: Not found (timeout)
Network 5: Wrong password (auth failure)
‚Üì
After 3 consecutive failures: Device marks credentials as "stale"
‚Üì
Device shows: "Known networks not available"
‚Üì
BLE pairing mode stays ON
‚Üì
Display shows: "No Internet - Scan QR to set up new network"
‚Üì
User scans ‚Üí BLE recovery ‚Üí Provisions new network
‚Üì
Device connects with new credential
‚Üì
Old stale credentials still cached but deprioritized
```

**Result:** Device doesn't waste battery on dead networks. Clear user recovery path.

</Accordion>

<Accordion title="Too Many Cached Networks (Which One to Try First?)">

**Scenario:** Device has cached 10 networks (home, office, coffee shops, airports...). All 10 are potentially reachable. Which to try first?

**What Happens:**
```
Device in RECOVERING state
‚Üì
Self-healing uses smart retry ordering:
‚Üì
Tier 1: Networks connected in last 7 days
  - OfficeNetwork (connected 2 days ago) - signal: -60 dBm
  - HomeNetwork (connected 1 day ago) - signal: -65 dBm
  ‚Üí Try: HomeNetwork first (most recent), then OfficeNetwork

Tier 2: Networks connected in last 30 days
  - CoffeeShop (connected 10 days ago) - signal: -55 dBm
  ‚Üí Try if Tier 1 fails

Tier 3: Networks connected ever (> 30 days ago)
  - AirportWiFi (connected 90 days ago)
  ‚Üí Deprioritized, only try if nothing else works
‚Üì
Device tries Tier 1 networks first (2 second timeout each)
‚Üì
HomeNetwork found ‚Üí Connects silently
‚Üì
Transition: RECOVERING ‚Üí CONNECTING ‚Üí ONLINE
```

**Result:** Device connects to most likely network first. Faster recovery. Doesn't waste time on old airports.

</Accordion>

<Accordion title="BLE Drops During Provisioning">

**Scenario:** User is sending WiFi credentials via BLE. BLE connection drops (out of range, interference).

**What Happens:**
```
User sending credentials via BLE
‚Üì
BLE connection drops mid-transfer
‚Üì
Device behavior:
- Credentials NOT written to storage (BLE write ACK never received)
- Device remains in RECOVERING state (pairing mode stays ON)
- Device waits for app to reconnect
‚Üì
App behavior:
- Detects: Write failure (no ACK within 30s timeout)
- App knows: Credentials were NOT received by device
- App shows: "Connection lost. Scan QR to try again."
‚Üì
User scans QR again ‚Üí BLE re-establishes
‚Üì
Device still in same state (no corruption)
‚Üì
User re-sends credentials ‚Üí Transition to CONNECTING
```

**Result:** BLE drops don't corrupt state. Built-in GATT write ACK protocol ensures safety. User can retry.

</Accordion>

<Accordion title="User Phone BLE is Disabled">

**Scenario:** Device is set up and working. Later, user disables Bluetooth on phone. Device goes offline. Now user can't recover via BLE.

**What Happens:**
```
Device in ONLINE state
‚Üì
WiFi fails ‚Üí Transition to RECOVERING
‚Üì
Display shows: "No Internet - Scan QR"
BLE turns ON
‚Üì
User scans QR ‚Üí App opens
‚Üì
App tries to search for BLE device
‚Üì
Detects: Phone Bluetooth is OFF
‚Üì
App shows: "Bluetooth is required for recovery. Enable Bluetooth?"
‚Üì
Provides: Direct link to iOS Bluetooth settings
‚Üì
User enables Bluetooth ‚Üí BLE scan succeeds
‚Üì
Recovery proceeds normally
‚Üì
(Future enhancement: If BLE truly unavailable for 2+ hours,
 device creates WiFi hotspot as fallback)
```

**Result:** App makes it obvious what to do. Future: Hotspot fallback for extreme cases.

</Accordion>

</Accordions>

---

## Design Principles

### 1. Never Silent Failures
Every failure is detected immediately and triggers appropriate state transition. No ambiguous "it's working but not really" states.

### 2. User Always Has Control
- In ONLINE: User can manually trigger recovery (tap "Change WiFi" in app)
- In RECOVERING: User can provision new network OR wait for self-healing
- In CONNECTING: User can cancel and try different network

### 3. Graceful Degradation
- Layer 1: Silent self-healing (user sees nothing)
- Layer 2: BLE recovery (if nearby with phone)
- Layer 3: Hotspot fallback (future - if BLE disabled)
- Each layer prevents previous layer failure

### 4. State Persistence
- Device always knows what state it's in
- App can resume if it crashes (prerequisites-based)
- User never feels "stuck" with no path forward

### 5. One System, Not Band-Aids
All scenarios are handled by the same state machine. No special-case code for each situation.

---

## Implementation Notes

### BLE Monitor = State Machine

The BLE Monitor from onboarding flow is the implementation of this state machine:

```
BLE Monitor watches WiFi status:
- WiFi OK ‚Üí State = ONLINE ‚Üí Monitor status = Green
- WiFi lost ‚Üí State = RECOVERING ‚Üí Monitor status = Amber
- WiFi connecting ‚Üí State = CONNECTING ‚Üí Monitor status = Amber

BLE Monitor also watches BLE health:
- BLE lost ‚Üí Monitor status = Red ‚Üí Fatal error (restart onboarding)
```

### State Machine Code Structure

```python
class ConnectivityStateMachine:
    state: Literal["ONLINE", "RECOVERING", "CONNECTING"]

    def on_wifi_lost(self):
        """WiFi dropped - enter recovery"""
        self.transition_to(RECOVERING)
        self.start_self_healing()  # Background process
        self.enable_ble_pairing()   # User recovery option
        self.display_qr_code()      # Visual feedback

    def on_cached_network_found(self, network):
        """Self-healing found a network"""
        self.transition_to(CONNECTING)
        self.attempt_connection(network)

    def on_user_provisions_wifi(self, ssid, password):
        """User provided new credentials"""
        self.transition_to(CONNECTING)
        self.attempt_connection(ssid, password)

    def on_wifi_connected(self):
        """WiFi connected - verify internet"""
        if self.verify_internet():
            self.transition_to(ONLINE)
            self.disable_ble_pairing()  # Safety net no longer needed
        else:
            # Connected but no internet - stay in recovery
            self.transition_to(RECOVERING)
            self.display_error("WiFi Connected, No Internet")

    def on_connection_failed(self):
        """Connection attempt failed"""
        self.transition_to(RECOVERING)
        # Self-healing continues, user can try again
```

---

## Summary

**The Persistent Connectivity State Machine is the foundational system that:**

1. **Unifies onboarding and recovery** - Same flow, same code, same UX
2. **Provides layered recovery** - Self-healing ‚Üí BLE ‚Üí Hotspot (future)
3. **Keeps device reachable** - Always either online (internet) or accessible (BLE)
4. **Respects user control** - User initiates recovery, user ends recovery
5. **Never fails silently** - Every error detected and handled explicitly
6. **Handles all scenarios** - No special-case code, just state transitions

**The state machine is already implemented in the onboarding flow. Recovery just reuses it.**
